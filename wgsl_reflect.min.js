var wgsl_reflect=function(exports){"use strict";class Token{constructor(type,lexeme,line){this._type=type;this._lexeme=lexeme;this._line=line}toString(){return`${this._lexeme}`}}Token.EOF={name:"EOF",type:"token",rule:-1};let Keyword={};class Scanner{constructor(source){this._source=source||"";this._tokens=[];this._start=0;this._current=0;this._line=1}scanTokens(){while(!this._isAtEnd()){this._start=this._current;if(!this.scanToken())throw`Invalid syntax at line ${this._line}`}this._tokens.push(new Token(Token.EOF,"",this._line));return this._tokens}scanToken(){let lexeme=this._advance();let matchToken=null;for(;;){if(this._isWhitespace(lexeme)){lexeme=this._advance();this._start++;continue}if(lexeme=="\n"){this._line++;lexeme=this._advance();this._start++;continue}if(lexeme=="/"){if(this._peekAhead()=="/"){while(lexeme!="\n"){lexeme=this._advance();this._start++;if(this._isAtEnd()){return true}}lexeme=this._advance();this._line++;continue}}let matchedToken=this._findToken(lexeme);if(lexeme==">"&&this._peekAhead()==">"){let foundLessThan=false;let ti=this._tokens.length-1;for(let count=0;count<4&&ti>=0;++count,--ti){if(this._tokens[ti]._type==Token.less_than){if(ti>0&&Token.template_types.indexOf(this._tokens[ti-1]._type)!=-1){foundLessThan=true}break}}if(foundLessThan){this._addToken(matchedToken);return true}}if(!matchedToken){let lookAheadLexeme=lexeme;let lookAhead=0;const maxLookAhead=2;for(let li=0;li<maxLookAhead;++li){lookAheadLexeme+=this._peekAhead(li);matchedToken=this._findToken(lookAheadLexeme);if(matchedToken){lookAhead=li;break}}if(!matchedToken){if(!matchToken)return false;this._current--;this._addToken(matchToken);return true}lexeme=lookAheadLexeme;this._current+=lookAhead+1}matchToken=matchedToken;if(this._isAtEnd())break;lexeme+=this._advance()}if(matchToken==null)return false;this._addToken(matchToken);return true}_findToken(lexeme){for(const name in Keyword){const token=Keyword[name];if(this._match(lexeme,token.rule)){return token}}for(const name in Token.Tokens){const token=Token.Tokens[name];if(this._match(lexeme,token.rule)){return token}}return null}_match(lexeme,rule){if(typeof rule=="string"){if(rule==lexeme){return true}}else{const match=rule.exec(lexeme);if(match&&match.index==0&&match[0]==lexeme)return true}return false}_isAtEnd(){return this._current>=this._source.length}_isWhitespace(c){return c==" "||c=="\t"||c=="\r"}_advance(amount){let c=this._source[this._current];amount=amount||0;amount++;this._current+=amount;return c}_peekAhead(offset){offset=offset||0;if(this._current+offset>=this._source.length)return"\0";return this._source[this._current+offset]}_addToken(type){const text=this._source.substring(this._start,this._current);this._tokens.push(new Token(type,text,this._line))}}Token.WgslTokens={decimal_float_literal:/((-?[0-9]*\.[0-9]+|-?[0-9]+\.[0-9]*)((e|E)(\+|-)?[0-9]+)?)|(-?[0-9]+(e|E)(\+|-)?[0-9]+)/,hex_float_literal:/-?0x((([0-9a-fA-F]*\.[0-9a-fA-F]+|[0-9a-fA-F]+\.[0-9a-fA-F]*)((p|P)(\+|-)?[0-9]+)?)|([0-9a-fA-F]+(p|P)(\+|-)?[0-9]+))/,int_literal:/-?0x[0-9a-fA-F]+|0|-?[1-9][0-9]*/,uint_literal:/0x[0-9a-fA-F]+u|0u|[1-9][0-9]*u/,ident:/[a-zA-Z][0-9a-zA-Z_]*/,and:"&",and_and:"&&",arrow:"->",attr_left:"[[",attr_right:"]]",forward_slash:"/",bang:"!",bracket_left:"[",bracket_right:"]",brace_left:"{",brace_right:"}",colon:":",comma:",",equal:"=",equal_equal:"==",not_equal:"!=",greater_than:">",greater_than_equal:">=",shift_right:">>",less_than:"<",less_than_equal:"<=",shift_left:"<<",modulo:"%",minus:"-",minus_minus:"--",period:".",plus:"+",plus_plus:"++",or:"|",or_or:"||",paren_left:"(",paren_right:")",semicolon:";",star:"*",tilde:"~",underscore:"_",xor:"^"};Token.WgslKeywords=["array","atomic","bool","f32","i32","mat2x2","mat2x3","mat2x4","mat3x2","mat3x3","mat3x4","mat4x2","mat4x3","mat4x4","ptr","sampler","sampler_comparison","struct","texture_1d","texture_2d","texture_2d_array","texture_3d","texture_cube","texture_cube_array","texture_multisampled_2d","texture_storage_1d","texture_storage_2d","texture_storage_2d_array","texture_storage_3d","texture_depth_2d","texture_depth_2d_array","texture_depth_cube","texture_depth_cube_array","texture_depth_multisampled_2d","u32","vec2","vec3","vec4","bitcast","block","break","case","continue","continuing","default","discard","else","elseif","enable","fallthrough","false","fn","for","function","if","let","loop","private","read","read_write","return","storage","switch","true","type","uniform","var","workgroup","write","r8unorm","r8snorm","r8uint","r8sint","r16uint","r16sint","r16float","rg8unorm","rg8snorm","rg8uint","rg8sint","r32uint","r32sint","r32float","rg16uint","rg16sint","rg16float","rgba8unorm","rgba8unorm_srgb","rgba8snorm","rgba8uint","rgba8sint","bgra8unorm","bgra8unorm_srgb","rgb10a2unorm","rg11b10float","rg32uint","rg32sint","rg32float","rgba16uint","rgba16sint","rgba16float","rgba32uint","rgba32sint","rgba32float"];Token.WgslReserved=["asm","bf16","const","do","enum","f16","f64","handle","i8","i16","i64","mat","premerge","regardless","typedef","u8","u16","u64","unless","using","vec","void","while"];function _InitTokens(){Token.Tokens={};for(let token in Token.WgslTokens){Token.Tokens[token]={name:token,type:"token",rule:Token.WgslTokens[token],toString:function(){return token}};Token[token]=Token.Tokens[token]}for(let i=0,l=Token.WgslKeywords.length;i<l;++i){Keyword[Token.WgslKeywords[i]]={name:Token.WgslKeywords[i],type:"keyword",rule:Token.WgslKeywords[i],toString:function(){return Token.WgslKeywords[i]}}}for(let i=0,l=Token.WgslReserved.length;i<l;++i){Keyword[Token.WgslReserved[i]]={name:Token.WgslReserved[i],type:"reserved",rule:Token.WgslReserved[i],toString:function(){return Token.WgslReserved[i]}}}Keyword.int32=Keyword.i32;Keyword.uint32=Keyword.u32;Keyword.float32=Keyword.f32;Keyword.pointer=Keyword.ptr;Token.storage_class=[Keyword.function,Keyword.private,Keyword.workgroup,Keyword.uniform,Keyword.storage];Token.access_mode=[Keyword.read,Keyword.write,Keyword.read_write];Token.sampler_type=[Keyword.sampler,Keyword.sampler_comparison];Token.sampled_texture_type=[Keyword.texture_1d,Keyword.texture_2d,Keyword.texture_2d_array,Keyword.texture_3d,Keyword.texture_cube,Keyword.texture_cube_array];Token.multisampled_texture_type=[Keyword.texture_multisampled_2d];Token.storage_texture_type=[Keyword.texture_storage_1d,Keyword.texture_storage_2d,Keyword.texture_storage_2d_array,Keyword.texture_storage_3d];Token.depth_texture_type=[Keyword.texture_depth_2d,Keyword.texture_depth_2d_array,Keyword.texture_depth_cube,Keyword.texture_depth_cube_array,Keyword.texture_depth_multisampled_2d];Token.texel_format=[Keyword.r8unorm,Keyword.r8snorm,Keyword.r8uint,Keyword.r8sint,Keyword.r16uint,Keyword.r16sint,Keyword.r16float,Keyword.rg8unorm,Keyword.rg8snorm,Keyword.rg8uint,Keyword.rg8sint,Keyword.r32uint,Keyword.r32sint,Keyword.r32float,Keyword.rg16uint,Keyword.rg16sint,Keyword.rg16float,Keyword.rgba8unorm,Keyword.rgba8unorm_srgb,Keyword.rgba8snorm,Keyword.rgba8uint,Keyword.rgba8sint,Keyword.bgra8unorm,Keyword.bgra8unorm_srgb,Keyword.rgb10a2unorm,Keyword.rg11b10float,Keyword.rg32uint,Keyword.rg32sint,Keyword.rg32float,Keyword.rgba16uint,Keyword.rgba16sint,Keyword.rgba16float,Keyword.rgba32uint,Keyword.rgba32sint,Keyword.rgba32float];Token.const_literal=[Token.int_literal,Token.uint_literal,Token.decimal_float_literal,Token.hex_float_literal,Keyword.true,Keyword.false];Token.literal_or_ident=[Token.ident,Token.int_literal,Token.uint_literal,Token.decimal_float_literal,Token.hex_float_literal];Token.element_count_expression=[Token.int_literal,Token.uint_literal,Token.ident];Token.template_types=[Keyword.vec2,Keyword.vec3,Keyword.vec4,Keyword.mat2x2,Keyword.mat2x3,Keyword.mat2x4,Keyword.mat3x2,Keyword.mat3x3,Keyword.mat3x4,Keyword.mat4x2,Keyword.mat4x3,Keyword.mat4x4,Keyword.atomic];Token.attribute_name=[Token.ident,Keyword.block]}_InitTokens();class AST{constructor(type,options){this._type=type;if(options){for(let option in options){this[option]=options[option]}}}}class Parser{constructor(){this._tokens=[];this._current=0}parse(tokensOrCode){this._initialize(tokensOrCode);let statements=[];while(!this._isAtEnd()){const statement=this._global_decl_or_directive();if(!statement)break;statements.push(statement)}return statements}_initialize(tokensOrCode){if(tokensOrCode){if(typeof tokensOrCode=="string"){const scanner=new Scanner(tokensOrCode);this._tokens=scanner.scanTokens()}else{this._tokens=tokensOrCode}}else{this._tokens=[]}this._current=0}_error(token,message){console.error(token,message);return{token:token,message:message,toString:function(){return`${message}`}}}_isAtEnd(){return this._current>=this._tokens.length||this._peek()._type==Token.EOF}_match(types){if(types.length===undefined){if(this._check(types)){this._advance();return true}return false}for(let i=0,l=types.length;i<l;++i){const type=types[i];if(this._check(type)){this._advance();return true}}return false}_consume(types,message){if(this._check(types))return this._advance();throw this._error(this._peek(),message)}_check(types){if(this._isAtEnd())return false;if(types.length!==undefined){let t=this._peek()._type;return types.indexOf(t)!=-1}return this._peek()._type==types}_advance(){if(!this._isAtEnd())this._current++;return this._previous()}_peek(){return this._tokens[this._current]}_previous(){return this._tokens[this._current-1]}_global_decl_or_directive(){while(this._match(Token.semicolon)&&!this._isAtEnd());if(this._match(Keyword.type)){const type=this._type_alias();this._consume(Token.semicolon,"Expected ';'");return type}if(this._match(Keyword.enable)){const enable=this._enable_directive();this._consume(Token.semicolon,"Expected ';'");return enable}const attrs=this._attribute_list();if(this._check(Keyword.var)){const _var=this._global_variable_decl();_var.attributes=attrs;this._consume(Token.semicolon,"Expected ';'.");return _var}if(this._check(Keyword.let)){const _let=this._global_constant_decl();_let.attributes=attrs;this._consume(Token.semicolon,"Expected ';'.");return _let}if(this._check(Keyword.struct)){const _struct=this._struct_decl();_struct.attributes=attrs;this._consume(Token.semicolon,"Expected ';'.");return _struct}if(this._check(Keyword.fn)){const _fn=this._function_decl();_fn.attributes=attrs;return _fn}return null}_function_decl(){if(!this._match(Keyword.fn))return null;const name=this._consume(Token.ident,"Expected function name.");this._consume(Token.paren_left,"Expected '(' for function arguments.");const args=[];if(!this._check(Token.paren_right)){do{const argAttrs=this._attribute_list();const name=this._consume(Token.ident,"Expected argument name.")._lexeme;this._consume(Token.colon,"Expected ':' for argument type.");const typeAttrs=this._attribute_list();const type=this._type_decl();type.attributes=typeAttrs;args.push(new AST("arg",{name:name,type:type}))}while(this._match(Token.comma))}this._consume(Token.paren_right,"Expected ')' after function arguments.");let _return=null;if(this._match(Token.arrow)){const attrs=this._attribute_list();_return=this._type_decl();_return.attributes=attrs}const body=this._compound_statement();return new AST("function",{name:name,args:args,return:_return,body:body})}_compound_statement(){const statements=[];this._consume(Token.brace_left,"Expected '{' for block.");while(!this._check(Token.brace_right)){const statement=this._statement();if(statement)statements.push(statement)}this._consume(Token.brace_right,"Expected '}' for block.");return statements}_statement(){while(this._match(Token.semicolon)&&!this._isAtEnd());if(this._check(Keyword.return)){const _return=this._return_statement();this._consume(Token.semicolon,"Expected ';' after statement.");return _return}if(this._check(Keyword.if))return this._if_statement();if(this._check(Keyword.switch))return this._switch_statement();if(this._check(Keyword.loop))return this._loop_statement();if(this._check(Keyword.for))return this._for_statement();if(this._check([Token.var,Token.let]))return this._variable_statement();if(this._check(Token.brace_left))return this._compound_statement();if(this._match(Keyword.discard)){this._consume(Token.semicolon,"Expected ';' after discard.");return new AST("discard")}if(this._match(Keyword.break)){this._consume(Token.semicolon,"Expected ';' after break.");return new AST("break")}if(this._match(Keyword.continue)){this._consume(Token.semicolon,"Expected ';' after continue.");return new AST("continue")}return this._func_call_statement()||this._assignment_statement()}_for_statement(){if(!this._match(Keyword.for))return null;this._consume(Token.paren_left,"Expected '(' for for loop.");const init=!this._check(Token.semicolon)?this._for_init():null;this._consume(Token.semicolon,"Expected ';'.");const condition=!this._check(Token.semicolon)?this._short_circuit_or_expression():null;this._consume(Token.semicolon,"Expected ';'.");const increment=!this._check(Token.paren_right)?this._for_increment():null;this._consume(Token.paren_right,"Expected ')' for for loop.");const body=this._compound_statement();return new AST("for",{init:init,condition:condition,increment:increment,body:body})}_for_init(){return this._variable_statement()||this._func_call_statement()||this._assignment_statement()}_for_increment(){return this._func_call_statement()||this._assignment_statement()}_variable_statement(){if(this._check(Keyword.var)){const _var=this._variable_decl();let value=null;if(this._match(Token.equal))value=this._short_circuit_or_expression();return new AST("var",{var:_var,value:value})}if(this._match(Keyword.let)){const name=this._consume(Token.ident,"Expected name for let.");let type=null;if(Token._match(Token.colon)){const typeAttrs=this._attribute_list();type=this._type_decl();type.attributes=typeAttrs}Token._consume(Token.equal,"Expected '=' for let.");const value=this._short_circuit_or_expression();return new AST("let",{name:name,type:type,value:value})}return null}_assignment_statement(){let _var=null;if(!this._match(Token.underscore))_var=this._unary_expression();this._consume(Token.equal,"Expected '='.");const value=this._short_circuit_or_expression();return new AST("assign",{var:_var,value:value})}_func_call_statement(){if(!this._check(Token.ident))return null;const savedPos=this._current;const name=this._consume(Token.ident,"Expected function name.");const args=this._argument_expression_list();if(args===null){this._current=savedPos;return null}return new AST("call",{name:name,args:args})}_loop_statement(){if(!this._match(Keyword.loop))return null;this._consume(Token.brace_left,"Expected '{' for loop.");const statements=[];let statement=this._statement();while(statement!==null){statements.push(statement);statement=this._statement()}let continuing=null;if(this._match(Keyword.continuing))continuing=this._compound_statement();this._consume(Token.brace_right,"Expected '}' for loop.");return new AST("loop",{statements:statements,continuing:continuing})}_switch_statement(){if(!this._match(Keyword.switch))return null;const condition=this._paren_expression();this._consume(Token.brace_left);const body=this._switch_body();if(body==null||body.length==0)throw this._error(this._previous(),"Expected 'case' or 'default'.");this._consume(Token.brace_right);return new AST("switch",{condition:condition,body:body})}_switch_body(){const cases=[];if(this._match(Token.case)){this._consume(Token.case);const selector=this._case_selectors();this._consume(Token.colon);this._consume(Token.brace_left);const body=this._case_body();this._consume(Token.brace_right);cases.push(new AST("case",{selector:selector,body:body}))}if(this._match(Token.default)){this._consume(Token.colon);this._consume(Token.brace_left);const body=this._case_body();this._consume(Token.brace_right);cases.push(new AST("default",{body:body}))}if(this._check([Token.default,Token.case])){const _cases=this._switch_body();cases.push(_cases[0])}return cases}_case_selectors(){const selectors=[this._consume(Token.const_literal,"Expected constant literal")._lexeme];while(this._match(Token.comma)){selectors.push(this._consume(Token.const_literal,"Expected constant literal")._lexeme)}return selectors}_case_body(){if(this._match(Keyword.fallthrough)){this._consume(Token.semicolon);return[]}const statement=this._statement();if(statement==null)return[];const nextStatement=this._case_body();if(nextStatement.length==0)return[statement];return[statement,nextStatement[0]]}_if_statement(){if(!this._match(Keyword.if))return null;const condition=this._paren_expression();const block=this._compound_statement();let elseif=null;if(this._match(Keyword.elseif))elseif=this._elseif_statement();let _else=null;if(this._match(Keyword.else))_else=this._compound_statement();return new AST("if",{condition:condition,block:block,elseif:elseif,else:_else})}_elseif_statement(){const elseif=[];const condition=this._paren_expression();const block=this._compound_statement();elseif.push(new AST("elseif",{condition:condition,block:block}));if(this._match(Keyword.elseif))elseif.push(this._elseif_statement()[0]);return elseif}_return_statement(){if(!this._match(Keyword.return))return null;const value=this._short_circuit_or_expression();return new AST("return",{value:value})}_short_circuit_or_expression(){let expr=this._short_circuit_and_expr();while(this._match(Token.or_or)){expr=new AST("compareOp",{operator:this._previous()._lexeme,left:expr,right:this._short_circuit_and_expr()})}return expr}_short_circuit_and_expr(){let expr=this._inclusive_or_expression();while(this._match(Token.and_and)){expr=new AST("compareOp",{operator:this._previous()._lexeme,left:expr,right:this._inclusive_or_expression()})}return expr}_inclusive_or_expression(){let expr=this._exclusive_or_expression();while(this._match(Token.or)){expr=new AST("binaryOp",{operator:this._previous()._lexeme,left:expr,right:this._exclusive_or_expression()})}return expr}_exclusive_or_expression(){let expr=this._and_expression();while(this._match(Token.xor)){expr=new AST("binaryOp",{operator:this._previous()._lexeme,left:expr,right:this._and_expression()})}return expr}_and_expression(){let expr=this._equality_expression();while(this._match(Token.and)){expr=new AST("binaryOp",{operator:this._previous()._lexeme,left:expr,right:this._equality_expression()})}return expr}_equality_expression(){const expr=this._relational_expression();if(this._match([Token.equal_equal,Token.not_equal])){return new AST("compareOp",{operator:this._previous()._lexeme,left:expr,right:this._relational_expression()})}return expr}_relational_expression(){let expr=this._shift_expression();while(this._match([Token.less_than,Token.greater_than,Token.less_than_equal,Token.greater_than_equal])){expr=new AST("compareOp",{operator:this._previous()._lexeme,left:expr,right:this._shift_expression()})}return expr}_shift_expression(){let expr=this._additive_expression();while(this._match([Token.shift_left,Token.shift_right])){expr=new AST("binaryOp",{operator:this._previous()._lexeme,left:expr,right:this._additive_expression()})}return expr}_additive_expression(){let expr=this._multiplicative_expression();while(this._match([Token.plus,Token.minus])){expr=new AST("binaryOp",{operator:this._previous()._lexeme,left:expr,right:this._multiplicative_expression()})}return expr}_multiplicative_expression(){let expr=this._unary_expression();while(this._match([Token.star,Token.forward_slash,Token.modulo])){expr=new AST("binaryOp",{operator:this._previous()._lexeme,left:expr,right:this._unary_expression()})}return expr}_unary_expression(){if(this._match([Token.minus,Token.bang,Token.tilde,Token.star,Token.and])){return new AST("unaryOp",{operator:this._previous()._lexeme,right:this._unary_expression()})}return this._singular_expression()}_singular_expression(){const expr=this._primary_expression();const p=this._postfix_expression();if(p)expr.postfix=p;return expr}_postfix_expression(){if(this._match(Token.bracket_left)){const expr=this._short_circuit_or_expression();this._consume(Token.bracket_right,"Expected ']'.");const p=this._postfix_expression();if(p)expr.postfix=p;return expr}if(this._match(Token.period)){const name=this._consume(Token.ident,"Expected member name.");const p=this._postfix_expression();if(p)name.postfix=p;return name}return null}_primary_expression(){if(this._match(Token.ident)){const name=this._previous();if(this._check(Token.paren_left)){const args=this._argument_expression_list();return new AST("call_expr",{name:name,args:args})}return new AST("variable_expr",{name:name})}if(this._match(Token.const_literal)){return new AST("literal_expr",{value:this._previous()})}if(this._check(Token.paren_left)){return this._paren_expression()}if(this._match(Keyword.bitcast)){this._consume(Token.less_than,"Expected '<'.");const type=this._type_decl();this._consume(Token.greater_than,"Expected '>'.");const value=this._paren_expression();return new AST("bitcast_expr",{type:type,value:value})}const type=this._type_decl();const args=this._argument_expression_list();return new AST("typecast_expr",{type:type,args:args})}_argument_expression_list(){if(!this._match(Token.paren_left))return null;const args=[];do{if(this._check(Token.paren_right))break;const arg=this._short_circuit_or_expression();args.push(arg)}while(this._match(Token.comma));this._consume(Token.paren_right,"Expected ')' for agument list");return args}_paren_expression(){this._consume(Token.paren_left,"Expected '('.");const expr=this._short_circuit_or_expression();this._consume(Token.paren_right,"Expected ')'.");return new AST("grouping_expr",{contents:expr})}_struct_decl(){if(!this._match(Keyword.struct))return null;const name=this._consume(Token.ident,"Expected name for struct.")._lexeme;this._consume(Token.brace_left,"Expected '{' for struct body.");const members=[];while(!this._check(Token.brace_right)){const memberAttrs=this._attribute_list();const memberName=this._consume(Token.ident,"Expected variable name.")._lexeme;this._consume(Token.colon,"Expected ':' for struct member type.");const typeAttrs=this._attribute_list();const memberType=this._type_decl();memberType.attributes=typeAttrs;this._consume(Token.semicolon,"Expected ';' after struct member.");members.push(new AST("member",{name:memberName,attributes:memberAttrs,type:memberType}))}this._consume(Token.brace_right,"Expected '}' after struct body.");return new AST("struct",{name:name,members:members})}_global_variable_decl(){const _var=this._variable_decl();if(this._match(Token.equal))_var.value=this._const_expression();return _var}_global_constant_decl(){if(!this._match(Keyword.let))return null;const name=this._consume(Token.ident,"Expected variable name");let type=null;if(this._match(Token.colon)){const attrs=this._attribute_list();type=this._type_decl();type.attributes=attrs}let value=null;if(this._match(Token.equal)){value=this._const_expression()}return new AST("let",{name:name._lexeme,type:type,value:value})}_const_expression(){if(this._match(Token.const_literal))return this._previous()._lexeme;const type=this._type_decl();this._consume(Token.paren_left,"Expected '('.");let args=[];while(!this._check(Token.paren_right)){args.push(this._const_expression());if(!this._check(Token.comma))break;this._advance()}this._consume(Token.paren_right,"Expected ')'.");return new AST("create",{type:type,args:args})}_variable_decl(){if(!this._match(Keyword.var))return null;let storage=null;let access=null;if(this._match(Token.less_than)){storage=this._consume(Token.storage_class,"Expected storage_class.");if(this._match(Token.comma))access=this._consume(Token.access_mode,"Expected access_mode.");this._consume(Token.greater_than,"Expected '>'.")}const name=this._consume(Token.ident,"Expected variable name");let type=null;if(this._match(Token.colon)){const attrs=this._attribute_list();type=this._type_decl();type.attributes=attrs}return new AST("var",{name:name._lexeme,type:type,storage:storage,access:access})}_enable_directive(){const name=this._consume(Token.ident,"identity expected.");return new AST("enable",{name:name._lexeme})}_type_alias(){const name=this._consume(Token.ident,"identity expected.");this._consume(Token.equal,"Expected '=' for type alias.");const alias=this._type_decl();return new AST("type_alias",{name:name._lexeme,alias:alias})}_type_decl(){if(this._check([Token.ident,Keyword.bool,Keyword.float32,Keyword.int32,Keyword.uint32])){const type=this._advance();return new AST("type",{name:type._lexeme})}if(this._check(Token.template_types)){let type=this._advance();this._consume(Token.less_than,"Expected '<' for type.");const format=this._type_decl();this._consume(Token.greater_than,"Expected '>' for type.");return new AST("type",{name:type._lexeme,format:format})}if(this._match(Keyword.pointer)){let pointer=this._previous();this._consume(Token.less_than,"Expected '<' for pointer.");const storage=this._consume(Token.storage_class,"Expected storage_class for pointer");this._consume(Token.comma,"Expected ',' for pointer.");const decl=this._type_decl();let access=null;if(this._match(Token.comma))access=this._consume(Token.access_mode,"Expected access_mode for pointer")._lexeme;this._consume(Token.greater_than,"Expected '>' for pointer.");return new AST("type",{name:pointer._lexeme,storage:storage._lexeme,decl:decl,access:access})}let type=this._texture_sampler_types();if(type)return type;const attrs=this._attribute_list();if(this._match(Keyword.array)){const array=this._previous();this._consume(Token.less_than,"Expected '<' for array type.");const format=this._type_decl();let count=null;if(this._match(Token.comma))count=this._consume(Token.element_count_expression,"Expected element_count for array.")._lexeme;this._consume(Token.greater_than,"Expected '>' for array.");return new AST("type",{name:array._lexeme,attributes:attrs,format:format,count:count})}return null}_texture_sampler_types(){if(this._match(Token.sampler_type))return new AST("sampler",{name:this._previous()._lexeme});if(this._match(Token.depth_texture_type))return new AST("sampler",{name:this._previous()._lexeme});if(this._match(Token.sampled_texture_type)||this._match(Token.multisampled_texture_type)){const sampler=this._previous();this._consume(Token.less_than,"Expected '<' for sampler type.");const format=this._type_decl();this._consume(Token.greater_than,"Expected '>' for sampler type.");return new AST("sampler",{name:sampler._lexeme,format:format})}if(this._match(Token.storage_texture_type)){const sampler=this._previous();this._consume(Token.less_than,"Expected '<' for sampler type.");const format=this._consume(Token.texel_format,"Invalid texel format.");this._consume(Token.comma,"Expected ',' after texel format.");const access=this._consume(Token.access_mode,"Expected access mode for storage texture type.");this._consume(Token.greater_than,"Expected '>' for sampler type.");return new AST("sampler",{name:sampler._lexeme,format:format,access:access})}return null}_attribute_list(){if(!this._match(Token.attr_left))return null;const attributes=[];if(!this._check(Token.attr_right)){do{const name=this._consume(Token.attribute_name,"Expected attribute name");const attr=new AST("attribute",{name:name._lexeme});if(this._match(Token.paren_left)){attr.value=this._consume(Token.literal_or_ident)._lexeme;this._consume(Token.paren_right,"Expected ')'")}attributes.push(attr)}while(this._match(Token.comma))}this._consume(Token.attr_right,"Expected ']]' after attribute declarations");return attributes}}const wgsl_reflect={Scanner:Scanner,Token:Token,Keyword:Keyword,AST:AST,Parser:Parser};exports.wgsl_reflect=wgsl_reflect;return exports}({});
